# Go, sqlc, and pgx: Understanding `string` vs. `*string`

When working with Go and relational databases like PostgreSQL using `pgx` and `sqlc`, a common point of decision—and potential confusion—is the choice between using a standard `string` and a pointer to a string (`*string`). This distinction is not merely syntactical; it is critical for correctly handling data integrity, JSON serialization, and the SQL `NULL` state.

## The Core Concept: Nullability

The fundamental difference lies in how Go represents the absence of data versus empty data, and how this maps to database schemas.

### `string` (Value Type)

In Go, a `string` is a value type. It cannot be `nil`. Its zero value is an empty string (`""`).

* **SQL Mapping:** This correlates to a database column defined as `NOT NULL`.
* **Semantics:** The data is guaranteed to exist. An empty string implies the user explicitly provided an empty text value.

### `*string` (Pointer Type)

A `*string` is a pointer to a string location in memory. It can be `nil`.

* **SQL Mapping:** This correlates to a database column defined as nullable (i.e., it lacks the `NOT NULL` constraint).
* **Semantics:** The data might be text, or it might be entirely missing (undefined).

In a database context, an empty string (`""`) and `NULL` are semantically distinct. `""` might represent a blank form entry, while `NULL` represents that the form was never seen. Using `*string` allows the application to preserve this distinction.

## Configuring sqlc for Pointers

By default, older configurations of `sqlc` or the standard `database/sql` library might use wrapper structs like `sql.NullString` or `pgtype.Text` to handle nullable columns. While these are type-safe, they are often considered cumbersome for modern application development.

To instruct `sqlc` to use native Go pointers for nullable columns (which integrates seamlessly with `pgx/v5`), the `sqlc.yaml` configuration file requires the `emit_pointers_for_null_types` setting:

```yaml
version: "2"
sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "db"
        out: "db"
        emit_pointers_for_null_types: true

```

With this setting enabled:

1. **`TEXT NOT NULL`** generates `string`.
2. **`TEXT`** (nullable) generates `*string`.

## The JSON Serialization Factor

One of the primary reasons developers prefer `*string` over wrapper types like `sql.NullString` or `pgtype.Text` is JSON marshaling. This is particularly relevant when the Go structs generated by `sqlc` are returned directly by a REST or GraphQL API.

### Using `*string`

When a `*string` is `nil`, the standard `encoding/json` package marshals it as a literal `null`.

```go
type User struct {
    Bio *string `json:"bio"`
}
// Result if nil: {"bio": null}
// Result if "hi": {"bio": "hi"}

```

This is idiomatic JSON and easily consumed by frontend frameworks like React or Vue.

### Using Wrappers (`sql.NullString`)

Wrapper types represent nullability via a boolean field (`Valid`).

```go
type User struct {
    Bio sql.NullString `json:"bio"`
}
// Result: {"bio": {"String": "some text", "Valid": true}}

```

This leaks implementation details (the database driver structure) to the API consumer, which is generally considered poor practice.

## Practical Usage and Safety

While `*string` offers better semantic mapping and JSON output, it introduces the risk of runtime panics. Accessing the value of a nil pointer causes a crash.

### Handling `string` (Safe)

When the type is `string`, no checks are needed:

```go
// Column is NOT NULL
func PrintUsername(name string) {
    fmt.Println(name) // Always safe
}

```

### Handling `*string` (Requires Care)

When the type is `*string`, developers must check for nil before dereferencing:

```go
// Column is Nullable
func PrintBio(bio *string) {
    // Unsafe: fmt.Println(*bio) -> Panics if bio is nil

    // Safe
    if bio != nil {
        fmt.Println(*bio)
    } else {
        fmt.Println("No bio provided")
    }
}

```

### Helper Functions

To mitigate the verbosity of nil checks, utility functions are often used:

```go
func StringOrEmpty(s *string) string {
    if s == nil {
        return ""
    }
    return *s
}

```

## Summary Comparison

| Feature | `string` | `*string` |
| --- | --- | --- |
| **SQL Constraint** | `NOT NULL` | Nullable |
| **Zero Value** | `""` (Empty string) | `nil` |
| **JSON Output** | `"string"` | `null` or `"string"` |
| **Safety** | High (No panics) | Moderate (Must check for nil) |
| **Use Case** | Mandatory fields (ID, Username) | Optional fields (Bio, Middle Name) |

In the context of `pgx/v5` and `sqlc`, utilizing `*string` for nullable columns is the modern standard, provided that developers practice defensive coding to handle potential nil values.
